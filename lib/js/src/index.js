// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var Fs                    = require("fs");
var Os                    = require("os");
var List                  = require("bs-platform/lib/js/list.js");
var $$Array               = require("bs-platform/lib/js/array.js");
var Block                 = require("bs-platform/lib/js/block.js");
var Curry                 = require("bs-platform/lib/js/curry.js");
var $$String              = require("bs-platform/lib/js/string.js");
var Process               = require("process");
var Brewconfig            = require("./brewconfig.js");
var Child_process         = require("child_process");
var Caml_missing_polyfill = require("bs-platform/lib/js/caml_missing_polyfill.js");

var installBrewScript = "/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"";

function bind(result, fn) {
  if (result.tag) {
    return /* Error */Block.__(1, [result[0]]);
  } else {
    return Curry._1(fn, result[0]);
  }
}

function commandToString(command) {
  switch (command) {
    case 0 : 
        return "help";
    case 1 : 
        return "unknown";
    case 2 : 
        return "init";
    
  }
}

var breweryConfig = Os.homedir() + "/.brewery.json";

function tryCatch(fn, error) {
  try {
    return Curry._1(fn, /* () */0);
  }
  catch (exn){
    return error;
  }
}

var stringOfBuffer = (
  function stringOfBuffer (buffer) { return buffer.toString(); }
);

function ifFn(condition, thenDo, elseDo) {
  if (Curry._1(condition, /* () */0)) {
    return Curry._1(thenDo, /* () */0);
  } else {
    return Curry._1(elseDo, /* () */0);
  }
}

function commandOfString(command) {
  var param = $$String.lowercase(command);
  switch (param) {
    case "help" : 
        return /* Help */0;
    case "init" : 
        return /* Init */2;
    default:
      return /* Unknown */1;
  }
}

function getCommand(args) {
  if (args) {
    return /* tuple */[
            commandOfString(args[0]),
            args[1]
          ];
  } else {
    return /* tuple */[
            /* Unknown */1,
            /* [] */0
          ];
  }
}

function parseArguments(args) {
  return $$Array.to_list($$Array.sub(args, 2, args.length - 2 | 0));
}

function writeBrewFile(fileExists, writeFile, brewConfig) {
  var match = Brewconfig.toJson(brewConfig);
  if (match) {
    var s = match[0];
    return ifFn((function () {
                  return Curry._1(fileExists, breweryConfig);
                }), (function () {
                  return /* Error */Block.__(1, [breweryConfig + " exists already"]);
                }), (function () {
                  Curry._2(writeFile, breweryConfig, s);
                  return /* Ok */Block.__(0, [".brewery.json created"]);
                }));
  } else {
    return /* Error */Block.__(1, ["unable to create initial brewery.json"]);
  }
}

function getInstalledFormulas(exec, _) {
  var getInstalledFormulas$1 = function () {
    var getInstalledFormulasFor = function (command) {
      var leaves = Curry._1(stringOfBuffer, Curry._1(exec, command));
      return List.map((function (s) {
                    return s;
                  }), $$Array.to_list(leaves.split("\n")));
    };
    return /* Ok */Block.__(0, [Brewconfig.make(getInstalledFormulasFor("brew leaves"), getInstalledFormulasFor("brew cask list"))]);
  };
  return tryCatch(getInstalledFormulas$1, /* Error */Block.__(1, ["error getting installed formulas"]));
}

function installBrew(exec, _) {
  return tryCatch((function () {
                Curry._1(exec, installBrewScript);
                return /* Ok */Block.__(0, [/* () */0]);
              }), /* Error */Block.__(1, ["error installing brew"]));
}

function isBrewInstalled(exec, _) {
  try {
    Curry._1(exec, "brew --version");
    return /* true */1;
  }
  catch (exn){
    return /* false */0;
  }
}

function execCommand(system, param) {
  var command = param[0];
  switch (command) {
    case 0 : 
        return /* Ok */Block.__(0, ["here some help"]);
    case 1 : 
        Curry._1(system[/* log */0], "I don't know " + (commandToString(command) + " command"));
        return /* Error */Block.__(1, [commandToString(command)]);
    case 2 : 
        var partial_arg = system[/* exec */2];
        var partial_arg$1 = system[/* exec */2];
        var partial_arg$2 = system[/* exec */2];
        var partial_arg$3 = system[/* writeFile */1];
        var partial_arg$4 = system[/* fileExists */3];
        return bind(bind(ifFn((function (param) {
                              return isBrewInstalled(partial_arg, param);
                            }), (function () {
                              return /* Ok */Block.__(0, [/* () */0]);
                            }), (function (param) {
                              return installBrew(partial_arg$1, param);
                            })), (function (param) {
                          return getInstalledFormulas(partial_arg$2, param);
                        })), (function (param) {
                      return writeBrewFile(partial_arg$4, partial_arg$3, param);
                    }));
    
  }
}

function run(system, stdin) {
  var res = execCommand(system, getCommand(parseArguments(stdin)));
  return Curry._1(system[/* log */0], res[0]);
}

function system_000(prim) {
  console.log(prim);
  return /* () */0;
}

function system_001(prim, prim$1) {
  Fs.writeFileSync(prim, prim$1, "utf8");
  return /* () */0;
}

function system_002(command) {
  return Child_process.execSync(command, { });
}

function system_003() {
  return Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n");
}

var system = /* record */[
  system_000,
  system_001,
  system_002,
  system_003
];

run(system, Process.argv);

var $great$great$eq = bind;

exports.installBrewScript    = installBrewScript;
exports.bind                 = bind;
exports.$great$great$eq      = $great$great$eq;
exports.commandToString      = commandToString;
exports.breweryConfig        = breweryConfig;
exports.tryCatch             = tryCatch;
exports.stringOfBuffer       = stringOfBuffer;
exports.ifFn                 = ifFn;
exports.commandOfString      = commandOfString;
exports.getCommand           = getCommand;
exports.parseArguments       = parseArguments;
exports.writeBrewFile        = writeBrewFile;
exports.getInstalledFormulas = getInstalledFormulas;
exports.installBrew          = installBrew;
exports.isBrewInstalled      = isBrewInstalled;
exports.execCommand          = execCommand;
exports.run                  = run;
exports.system               = system;
/* breweryConfig Not a pure module */
